<?php
// $Id$

/**
 * @file
 * Defines a persons name field type.
 */

/**
 * Implementation of hook_field_info().
 */
function name_field_info() {
  return array(
    'name' => array(
      'label' => t('Name'),
      'description' => t('This field stores a users title, given, middle, family name, generational suffix and credentials in the database.'),
      'field_settings' => array(
        // Components used. At least given or family name is required.
        'components' => array(
          'title',
          'given',
          'middle',
          'family',
          'generational',
          'credentials',
        ),
        // Minimal set of components before considered incomplete
        'minimum_components' => array(
          'given',
          'family',
        ),
        'labels' => _name_translations(),
        'max_length' => array(
          'title' => 31,
          'given' => 63,
          'middle' => 127,
          'family' => 63,
          'generational' => 15,
          'credentials' => 255,
        ),
        // TODO: Hook into a vocab to generate these. [vocabulary:vid]
        'title_options' => implode("\n", array(t('-- -- '), t('Mr.'), t('Mrs.'), t('Miss'), t('Ms.'), t('Dr.'), t('Prof.'))),
        'generational_options' => implode("\n", array(t('-- -- '), t('Jr.'), t('Sr.'), t('I'), t('II'), t('III'), t('IV'), t('V'), t('VI'), t('VII'), t('VIII'), t('IX'), t('X'))),
      ),
      'instance_settings' => array(
        // Possible elements for either (free) text, autocomplete, select.
        'title_field' => 'select',
        'generational_field' => 'select',
        'size' => array(
          'title' => 6,
          'given' => 20,
          'middle' => 20,
          'family' => 20,
          'generational' => 5,
          'credentials' => 35,
        ),
      ),
    ),
  );
}

/**
 * Statically cache these so we can reuse them without
 * multiple redundant t() calls.
 */
function _name_translations($intersect = NULL) {
  $nt = NULL;
  if (!isset($nt)) {
    $nt = array(
      'title' => t('Title'),
      'given' => t('Given'),
      'middle' => t('Middle name(s)'),
      'family' => t('Family'),
      'generational' => t('Generational'),
      'credentials' => t('Credentials'),
    );
  }
  return empty($intersect) ? $nt : array_intersect_key($nt, $intersect);
}

/**
 * Helper function to set the defaults for a name field / widget.
 */
function _name_defaults(&$field, $key) {
  $name_info = name_field_info();
  $field[$key] = (array) $field[$key];
  foreach ($name_info['name'][$key] as $index => $defaults) {
    if (!isset($field[$key][$index])) {
      if (is_array($defaults)) {
        if (!array_key_exists($index, $field[$key])) {
          $field[$key][$index] = array();
        }
        $field[$key][$index] += $defaults;
      }
      else {
        $field[$key][$index] = $defaults;
      }
    }
  }
}

/**
 * Implementation of hook_field_settings().
 */
function name_field_settings($op, $field) {
  _name_defaults($field, 'field_settings');
  switch ($op) {
    case 'form':
      $form = array(
        'field_settings' => array('#tree' => TRUE)
      );
      $components = _name_translations();
      $form['field_settings']['components'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Components'),
        '#default_value' => $field['field_settings']['components'],
        '#required' => TRUE,
        '#description' => t('Only selected components will be activated on this field. All non-selected components / component settings will be ignored.'),
        '#options' => $components,
        '#element_validate' => array('_name_field_minimal_component_requirements'),
      );

      $form['field_settings']['minimum_components'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Minimum components'),
        '#default_value' => $field['field_settings']['minimum_components'],
        '#required' => TRUE,
        '#element_validate' => array('_name_field_minimal_component_requirements'),
        '#description' => t('The minimal set of components required before considered the name field to be incomplete.'),
        '#options' => $components,
      );
      $form['field_settings']['labels'] = array();
      $form['field_settings']['max_length'] = array();
      foreach ($components as $key => $title) {
        $form['field_settings']['max_length'][$key] = array(
          '#type' => 'textfield',
          '#title' => t('Maximum length for !title', array('!title' => $title)),
          '#default_value' => $field['field_settings']['max_length'][$key],
          '#required' => FALSE,
          '#size' => 10,
          '#description' => t('The maximum length of the field in characters. This must be between 1 and 255.'),
          '#element_validate' => array('_name_validate_integer_positive'),
        );
        $form['field_settings']['labels'][$key] = array(
          '#type' => 'textfield',
          '#title' => t('Label for !title', array('!title' => $title)),
          '#default_value' => $field['field_settings']['labels'][$key],
          '#required' => TRUE,
        );
      }
      $title_options = implode("\n", array_filter(explode("\n", $field['field_settings']['title_options'])));
      $form['field_settings']['title_options'] = array(
        '#type' => 'textarea',
        '#title' => t('Title options'),
        '#default_value' => $title_options,
        '#required' => TRUE,
        '#description' => t("Enter one title per line. Prefix a line using '--' to specifiy a blank value text. For example: '--Please select a title'."),
      );
      $generational_options = implode("\n", array_filter(explode("\n", $field['field_settings']['generational_options'])));
      $form['field_settings']['generational_options'] = array(
        '#type' => 'textarea',
        '#title' => t('Generational options'),
        '#default_value' => $generational_options,
        '#required' => TRUE,
        '#description' => t("Enter one generational option per line. Prefix a line using '--' to specifiy a blank value text. For example: '----'"),
      );
      return $form;

    case 'validate':
      // Validates options against the title / generational sizes.
      _element_validate_options_size($field['field_settings']['title_options'],
          $field['field_settings']['max_length']['title'], t('Title options'));
      _element_validate_options_size($field['field_settings']['generational_options'],
          $field['field_settings']['max_length']['generational'], t('Generational options'));
      _name_field_settings_validate($field);
      break;

    case 'save':
      return array('field_settings');

    case 'database columns':
      $components = array_filter($field['field_settings']['components']);
      $columns = array();
      foreach (_name_translations($components) as $key => $title) {
        $max = $field['field_settings']['max_length'][$key];
        $columns[$key] = array(
          'type' => 'varchar',
          'length' => is_numeric($max) ? $max : 255,
          'not null' => FALSE,
          'sortable' => TRUE,
          'views' => TRUE,
        );
      }
      return $columns;
    case 'views data':
      $data = content_views_field_views_data($field);
      $db_info = content_database_info($field);
      $table_alias = content_views_tablename($field);
      $field_data = $data[$table_alias][$field['field_name'] .'_value'];
      // Make changes to $data as needed here.
      return $data;
  }
}

/**
 * Drupal does not validate checkboxes by default. With checkbox validate, the
 * user may get two error messages.
 */
function _name_field_minimal_component_requirements($element, &$form_state) {
  $required_field_set = array_flip(array('given', 'middle', 'family'));
  $value = array_intersect_key($required_field_set, array_filter((array)$element['#value']));
  if (empty($value)) {
    $required_fields = array_intersect_key(_name_translations(), $required_field_set);
    form_set_error(implode('][', $element['#parents']) .'][given',
        t('%label must have one of the following components: %components',
        array('%label' => $element['#title'], '%components' => implode(', ', $required_fields))));
  }

}

/**
* Custom validation of settings values.
*/
function _name_validate_integer_positive($element, &$form_state) {
  $value = $element['#value'];
  if ($value && !is_numeric($value)|| $value < 1 || $value > 255) {
    form_set_error(implode('][', $element['#array_parents']), t('%label must be a number between 1 and 255.', array('%label' => $element['#title'])));
  }
}

function _name_field_settings_validate($field) {
  $settings = $field['field_settings'];
  $diff = array_diff_key(array_filter($settings['minimum_components']), array_filter($settings['components']));
  if (count($diff)) {
    $components = array_intersect_key(_name_translations(), $diff);
    form_set_error('field_settings][minimum_components]['. key($diff),
        t('The following components for %label are not selected for this name field: %components',
        array('%label' => t('Minimum components'), '%components' => implode(', ', $components))));

  }
}

/**
* Implementation of hook_field().
*/
function name_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {
    case 'validate':
      // Validation on required is done here.
      // The max. length is done via Drupal.
      // Min. components is done via name_element validation callback.
      if ($field['required']) {
        if (is_array($items)) {
          foreach ($items as $delta => $item) {
            if (!name_content_is_empty($item, $field)) {
              return $items;
            }
          }
        }
        $error_element = empty($items[0]['_error_element']) ? '' : $items[0]['_error_element'] .'][';
        $error_element .= $field['field_name'] .'[0]'; // TODO
        form_set_error($error_element, t('%label is required.', array('%label' => $field['widget']['label'])));
      }
      return $items;

    case 'sanitize':
      foreach ($items as $delta => $item) {
        foreach (_name_translations() as $key => $title) {
          $items[$delta]['safe'][$key] = check_plain($item[$key]);
        }
      }
  }
}

/**
 * Implementation of hook_content_is_empty().
 */
function name_content_is_empty($item, $field) {
  foreach (_name_translations() as $key => $title) {
    // Title has no meaning by itself.
    if ($key == 'title' || $key == 'generational') {
      continue;
    }
    if (!empty($item[$key])) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Implement hook_theme().
 */
function name_theme() {
  $theme = array(
    'name_element' => array(
      'arguments' => array('element' => NULL),
//      'template' => 'name-element',
    ),
    'name_formatter_default' => array(
      'arguments' => array('element' => NULL),
    ),
    'name_formatter_plain' => array(
      'arguments' => array('element' => NULL),
    ),
  );
  return $theme;
}

/**
 * Implementation of hook_field_formatter_info().
 */
function name_field_formatter_info() {
  $formatters = array();
  foreach (array('default' => t('Default'), 'plain' => t('Plain')) as $type => $title) {
    $formatters[$type] = array(
      'label' => $title,
      'field types' => array('name'),
      'multiple values' => CONTENT_HANDLE_CORE,
    );
  }
  return $formatters;
}

/**
 * Theme function for 'default' example field formatter.
 */
function theme_name_formatter_default($element) {
  $parts = array();
  foreach (_name_translations() as $key => $title) {
    if (!empty($element['#item']['safe'][$key])) {
      $parts[$key] = $element['#item']['safe'][$key];
    }
    else {
      $parts[$key] = NULL;
    }
  }
  return name_construct_components($parts);
}

/**
 * Constructs the individual parts into a single string.
 * E.g. "Dr. Charles Augustus Phillips, Jr., DDS"
 */
function name_construct_components($parts) {
  global $language;
  $name_parts = array();
  switch ($language) {
    // TODO what locales use the surname first
    case 'cn':
      $name_parts = array_filter(array($parts['title'], $parts['family'], $parts['given'], $parts['middle']));
      break;
    default:
      $name_parts = array_filter(array($parts['title'], $parts['given'], $parts['middle'], $parts['family']));
      break;
  }
  return implode(', ', array_filter(array(implode(' ', $name_parts), $parts['generational'], $parts['credentials'])));
}

/**
 * Theme function for 'plain' example field formatter.
 */
function theme_name_formatter_plain($element) {
  return strip_tags(theme('name_formatter_default', $element));
}

/**
 * Implementation of hook_widget_info().
 */
function name_widget_info() {
  return array(
    'name_widget' => array(
      'label' => t('Name'),
      'field types' => array('name'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
* Implementation of hook_widget_settings().
*/
function name_widget_settings($op, $widget) {
  switch ($op) {
    case 'form':
      $form = array();
      $form['instance_settings'] = array(
        '#tree' => TRUE,
      );
      _name_defaults($widget, 'instance_settings');
      $components = _name_translations();
      $form['instance_settings']['size'] = array();
      foreach ($components as $key => $title) {
        $form['instance_settings']['size'][$key] = array(
          '#type' => 'textfield',
          '#title' => t('HTML size property for !title', array('!title' => $title)),
          '#default_value' => $widget['instance_settings']['size'][$key],
          '#required' => FALSE,
          '#size' => 10,
          '#description' => t('The maximum length of the field in characters. This must be between 1 and 255.'),
          '#element_validate' => array('_name_validate_integer_positive'),
        );
      }
      $form['instance_settings']['title_field'] = array(
        '#type' => 'radios',
        '#title' => t('Title field type'),
        '#default_value' => $widget['instance_settings']['title_field'],
        '#required' => TRUE,
        '#options' => array('select' => t('Drop-down')),
      );
      $form['instance_settings']['generational_field'] = array(
        '#type' => 'radios',
        '#title' => t('Generational field type'),
        '#default_value' => $widget['instance_settings']['generational_field'],
        '#required' => TRUE,
        '#options' => array('select' => t('Drop-down')),
      );
      return $form;

    case 'save':
      return array('instance_settings');
  }
}

/**
 * Implementation of hook_widget().
 */
function name_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  $widget = $field['widget'];
  _name_defaults($widget, 'instance_settings');
  _name_defaults($field, 'field_settings');
  $fs = $field['field_settings'];
  $ws = $widget['instance_settings'];
  $element = array(
    '#type' => 'name_element',
    '#title' => $widget['label'],
    '#label' => $widget['label'],
    '#components' => array(),
    '#minimum_components' => array_filter($fs['minimum_components']),
    '#default_value' => isset($items[$delta]) ? $items[$delta] : NULL,
  );
  $components = array_filter($fs['components']);
  foreach (_name_translations() as $key => $title) {
    if (in_array($key, $components)) {
      $element['#components'][$key]['type'] = 'textfield';
      $element['#components'][$key]['description'] = check_plain($fs['labels'][$key]);
      $size = !empty($ws['size'][$key]) ? $ws['size'][$key] : 60;
      $element['#components'][$key]['size'] = $size;
      $element['#components'][$key]['maxlength'] = !empty($fs['max_length'][$key]) ? $fs['max_length'][$key] : 255;
      if (isset($ws[$key .'_field']) && $ws[$key .'_field'] == 'select') {
        $element['#components'][$key]['type'] = 'select';
        $element['#components'][$key]['size'] = 1;

        $options = array_filter(explode("\n", $fs[$key .'_options']));
        // Roman numerials do not sort!
        if ($key == 'title') {
          natcasesort($options);
        }
        $default = FALSE;
        foreach ($options as $index => $opt) {
          if (strpos($opt, '--') === 0) {
            unset($options[$index]);
            $default = substr($opt, 2);
          }
        }
        $options = drupal_map_assoc(array_map('trim', $options));
        if ($default !== FALSE) {
          $options = array('' => $default) + $options;
        }
        $element['#components'][$key]['options'] = $options;
      }
      elseif (isset($ws[$key .'_field']) && $ws[$key .'_field'] == 'autocomplete') {
        // TODO $element['#components'][$key]['autocomplete'] = '';
      }
    }
    else {
      $element['#components'][$key]['exclude'] = TRUE;
    }
  }

  // Used so that hook_field('validate') knows where to
  // flag an error in deeply nested forms.
  if (empty($form['#parents'])) {
    $form['#parents'] = array();
  }
  $element['_error_element'] = array(
    '#type' => 'value',
    '#value' => implode('][', $form['#parents']),
  );
  return $element;
}

/**
 * Helper form element validator.
 */
function _element_validate_options_size($field_options, $max_length, $label) {
  $values = array_filter(explode("\n", $field_options));
  $long_options = array();
  $options = array();
  foreach ($values as $value) {
    $value = trim($value);
    // Blank option - anything goes!
    if (strpos($value, '--') === 0) {
      $options [] = $value;
    }
    elseif (drupal_strlen($value) > $max_length) {
      $long_options [] = $value;
    }
    elseif (!empty($value)) {
      $options [] = $value;
    }
  }
  if (count($long_options)) {
    form_set_error('field_settings][title_options', t('The following options exceed the maximun allowed %label length: %options', array('%options' => implode(', ', $long_options), '%label' => $label)));
  }
  elseif (empty($options)) {
    form_set_error('field_settings][title_options', t('%label are required.', array('%label' => $label)));
  }
}

/**
 * Implementation of hook_token_list() and hook_token_values().
 */
function name_token_list($type = 'all') {
  if ($type == 'field' || $type == 'all') {
    $tokens = array();
    $tokens['name']['raw']       = t('Raw full name');
    $tokens['name']['formatted'] = t('Full Name');
    foreach (_name_translations() as $key => $title) {
      $tokens['name'][$key .'-raw']       = t('Raw %part', array('%part' => $title));
      $tokens['name'][$key .'-formatted'] = t('%part', array('%part' => $title));
    }
    return $tokens;
  }
}

function name_token_values($type, $object = NULL) {
  if ($type == 'field') {
    $item = $object[0];

    $raw_parts = array();
    $safe_parts = array();
    foreach (_name_translations() as $key => $title) {
      if (!empty($item[$key])) {
        $raw_parts[$key] = $item[$key];
        $safe_parts[$key] = check_plain($item[$key]);
      }
      else {
        $raw_parts[$key] = '';
        $safe_parts[$key] = '';
      }
    }

    $tokens['raw'] = name_construct_components($raw_parts);
    $tokens['formatted'] = name_construct_components($safe_parts);

    foreach (_name_translations() as $key => $title) {
      $tokens[$key .'-raw']       = $raw_parts[$key];
      $tokens[$key .'-formatted'] =  $safe_parts[$key];
    }
    return $tokens;
  }
}

/**
 * Implementation of hook_elements().
 */
function name_elements() {
  $parts = _name_translations();
  $field_info = name_field_info();
  $name_info = $field_info['name'];
  return array(
    'name_element' => array(
      '#input' => TRUE,
      '#process' => array('name_element_expand'),
      '#element_validate' => array('name_element_validate'),
      '#pre_render' =>  array('name_element_pre_render'),
      '#default_value' => array('title' => '', 'given' => '', 'middle' => '',
          'family' => '', 'generational' => '', 'credentials' => ''),
      '#minimum_components' => $name_info['field_settings']['minimum_components'],
      '#components' => array(
        'title' => array(
          'type' => $name_info['instance_settings']['title_field'],
          'description' => $parts['title'],
          'size' => $name_info['instance_settings']['size']['title'],
          'maxlength' => $name_info['field_settings']['max_length']['title'],
          'options' => $name_info['field_settings']['title_options'],
          'autocomplete' => FALSE,
        ),
        'given' => array(
          'type' => 'textfield',
          'description' => $parts['given'],
          'size' => $name_info['instance_settings']['size']['given'],
          'maxlength' => $name_info['field_settings']['max_length']['given'],
          'autocomplete' => FALSE,
        ),
        'middle' => array(
          'type' => 'textfield',
          'description' => $parts['middle'],
          'size' => $name_info['instance_settings']['size']['middle'],
          'maxlength' => $name_info['field_settings']['max_length']['middle'],
          'autocomplete' => FALSE,
        ),
        'family' => array(
          'type' => 'textfield',
          'description' => $parts['family'],
          'size' => $name_info['instance_settings']['size']['family'],
          'maxlength' => $name_info['field_settings']['max_length']['family'],
          'autocomplete' => FALSE,
        ),
        'generational' => array(
          'type' => $name_info['instance_settings']['generational_field'],
          'description' => $parts['generational'],
          'size' => $name_info['instance_settings']['size']['generational'],
          'maxlength' => $name_info['field_settings']['max_length']['generational'],
          'options' => $name_info['field_settings']['generational_options'],
          'autocomplete' => FALSE,
        ),
        'credentials' => array(
          'type' => 'textfield',
          'description' => $parts['credentials'],
          'size' => $name_info['instance_settings']['size']['credentials'],
          'maxlength' => $name_info['field_settings']['max_length']['credentials'],
          'autocomplete' => FALSE,
        ),
      ),
    )
  );
}

/**
 * Custom theme callback for the name_element.
 * TODO - template for this
 */
function theme_name_element($element) {
  return theme('form_element', $element, $element['#children']);
}

/**
 * The #process callback to create the element.
 */
function name_element_expand($element, $edit, &$form_state, $complete_form) {
  $element['#tree'] = TRUE;
  if (!isset($element['#value'])) {
    $element['#value'] = array('title' => '', 'given' => '', 'middle' => '',
        'family' => '', 'generational' => '', 'credentials' => '');
  }
  $components = $element['#components'];
  $min_components = (array) $element['#minimum_components'];
  foreach (_name_translations() as $key => $title) {
    if (!isset($components[$key]['exclude'])) {
      $element[$key] = _name_render_component($components[$key], $key, $element['#value'][$key], isset($min_components[$key]));
      if ($key == 'credentials') {
        $element[$key]['#prefix'] = '<div class="clear-block" style="float: left;">';
        $element[$key]['#suffix'] = '</div>';
      }
      else {
        $element[$key]['#prefix'] = '<div style="float: left; margin-right: 1em;">';
        $element[$key]['#suffix'] = '</div>';
      }
    }
  }
  $element['#suffix'] = '<div class="clear-block"></div>';
  return $element;
}

function _name_render_component($component, $name, $value, $core) {
  $element = array(
    '#attributes' => array(
      'class' => 'name-element name-'. $name . ($core ? ' name-core-component' : ''),
    ),
  );
  $base_attributes = array('type', 'description', 'size', 'maxlength');
  foreach ($base_attributes as $key) {
    $element['#'. $key] = $component[$key];
  }
  $element['#default_value'] = $value;
  if ($component['type'] == 'select') {
    $element['#options'] = $component['options'];
    $element['#size'] = 1;
  }
  elseif (!empty($component['autocomplete'])) {
    $element['#autocomplete_path'] = $component['autocomplete'];
  }
  return $element;
}

function name_element_validate($element, &$form_state) {
  $minimum_components = array_filter($element['#minimum_components']);
  $labels = array();
  foreach ($element['#components'] as $key => $component) {
    if (!isset($component['exclude'])) {
      $labels[$key] = $component['description'];
    }
  }
  $item = $element['#value'];
  $empty = name_content_is_empty($item, NULL);
  $item_components = array();
  foreach (_name_translations() as $key => $title) {
    if (isset($labels[$key]) && !empty($item[$key])) {
      $item_components[$key] = $item[$key];
    }
  }
  if (!$empty && (count($minimum_components) != count(array_intersect_key($minimum_components, $item_components)))) {
    $missing_labels = array_diff_key(array_intersect_key($labels, $minimum_components), $item_components);
    $label = empty($element['#title']) ? (empty($element['#label']) ? 'Field' : $element['#label']) : $element['#title'];
    form_error($element[key($missing_labels)], t('%name also requires the following parts: %components.',
      array('%name' => $label, '%components' => implode(', ', $missing_labels))));
  }

  return $element;
}

/**
 * This forces the error class attribute onto the element components.
 *
 * TODO: There is alot of WTF here. Why does this need such a hack to
 * propagate the error class down?
 */
function name_element_pre_render($element) {
  $error_element = empty($element['_error_element']['#value']) ? '' : $element['_error_element']['#value'] .'][';
  $error_element .= $element['#name'];
  $errors = (array) form_set_error();
  foreach ($errors as $error_key => $error) {
    if (strpos($error_key, $error_element) === 0) {
      foreach (_name_translations() as $key => $title) {
        if (isset($element[$key]) && empty($element[$key]['#value'])) {
          $element[$key]['#attributes']['class'] .= ' error';
        }
      }
    }
  }
  return $element;
}
