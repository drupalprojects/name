<?php
// $Id$

/**
 * @file
 * Defines an API for displaying and inputing names.
 */

/**
 * This is the main function that formats a name from an array of components.
 *
 * @param array $name_components
 *        A keyed array of name components.
 *        These are: title, given, middle, family, generational and credentials.
 * @param string $format
 *        The string specifying what format to use.
 * @param array $settings
 *        A keyed array of additional parameters to pass into the function.
 *        Includes:
 *          'object' - An object or array.
 *            This object is used for Token module subsitutions.
 *          'type' - A string.
 *            The object identifier: node, user, etc
 */
function name_format($name_components, $format, $settings = array()) {
  module_load_include('inc', 'name', 'includes/name.parser');
  return _name_format($name_components, $format, $settings);
}

/**
 * Handles the initialization of the Name module settings that
 * are stored in the {variables} table.
 */
function name_settings($key = NULL) {
  $settings = variable_get('name_settings', array());
  $settings += array(
    'default_format' => 't+ig+im+if+is+kc',
    'sep1' => ' ',
    'sep2' => ', ',
    'sep3' => '',
  );
  if ($key) {
    return $settings[$key];
  }
  return $settings;
}

/**
 * Implementation of hook_init().
 *
 * The module's focus has changed from being a simplet field provider, to an
 * API with addition fields.
 *
 * These are only loaded when the required modules are present.
 */
function name_init() {
  if (module_exists('token')) {
    module_load_include('inc', 'name', 'includes/name.token');
  }
  if (module_exists('content')) {
    module_load_include('inc', 'name', 'includes/name.content');
  }
}

/**
 * Implementation of hook_menu().
 */
function name_menu() {
  $items = array();

  // Admin menu items
  $items['admin/settings/name'] = array(
    'title' => 'Name',
    'page callback' => 'name_list_custom_formats',
    'description' => 'List custom name formats.',
    'access arguments' => array('administer site configuration'),
    'file' => 'name.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/settings/name/list'] = array(
    'title' => 'Custom formats',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/settings/name/add'] = array(
    'title' => 'Add custom format',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('name_custom_formats_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'name.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/settings/name/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('name_admin_settings_form'),
    'description' => 'Administer the Names module and custom name formats.',
    'access arguments' => array('administer site configuration'),
    'file' => 'name.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );
  $items['admin/settings/name/%'] = array(
    'title' => 'Edit custom format',
    'page callback' => 'name_custom_format_edit',
    'page arguments' => array(3),
    'access arguments' => array('administer site configuration'),
    'file' => 'name.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/settings/name/%/delete'] = array(
    'title' => 'Delete custom name format',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('name_custom_format_delete_form', 3),
    'access arguments' => array('administer site configuration'),
    'file' => 'name.admin.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implement hook_theme().
 */
function name_theme() {
  $theme = array(
    // Themes the FAPI element.
    'name_element' => array(
      'arguments' => array('element' => NULL),
    ),

    // Provides the help for the recognized characters
    // in the name_format() format parameter.
    'name_format_parameter_help' => array(
      'file' => 'includes/name.parser.inc',
    ),
  );

  if (module_exists('content')) {
    name_additional_content_theme($theme);
  }

  return $theme;
}

/**
 * Loads a list of all user defined formats.
 */
function name_get_custom_formats() {
  static $formats;
  if (!isset($formats)) {
    $formats = array();
    $result = db_query("SELECT * FROM {name_custom_format} ORDER BY name ASC");
    while ($row = db_fetch_array($result)) {
      $formats[$row['ncfid']] = $row;
    }
  }
  return $formats;
}

/**
 * Helper function to generate a list of all defined custom
 * formatting options.
 */
function name_get_custom_format_options() {
  $options = array();
  foreach (name_get_custom_formats() as $wcfid => $row) {
    $options[$row['machine_name']] = $row['name'];
  }
  natcasesort($options);
  return $options;
}

function name_get_format_by_machine_name($machine_name) {
  if ($machine_name == 'default') {
    return name_settings('default_format');
  }
  $sql = "SELECT format FROM {name_custom_format} WHERE machine_name = '%s'";
  return (string) db_result(db_query($sql, $machine_name));
}

/**
 * Static cache to reuse translated name components.
 */
function _name_translations($intersect = NULL) {
  $nt = NULL;
  if (!isset($nt)) {
    $nt = array(
      'title' => t('Title'),
      'given' => t('Given'),
      'middle' => t('Middle name(s)'),
      'family' => t('Family'),
      'generational' => t('Generational'),
      'credentials' => t('Credentials'),
    );
  }
  return empty($intersect) ? $nt : array_intersect_key($nt, $intersect);
}

/**
 * Private helper function to define the formatter types that are available for
 * the CCK and Token modules.
 */
function _name_formatter_output_types() {
  return array(
    'default' => t('Default'),
    'plain' => t('Plain'),
    'raw' => t('Raw'));
}

/**
 * A brigding function to warn users that are using any custom code.
 *
 * TODO: Remove from Drupal 7 and latter branches past 6-1.x.
 */
function name_construct_components() {
  $warning = FALSE;
  if (!$warning) {
    drupal_set_message(t('The function "%func" is do longer available. This code should be refactored to use "name_format".'), 'error');
    $warning = TRUE;
  }
  return '';
}

/* ----------------------- FAPI Element Code ------------------------------------- */

/**
 * Implementation of hook_elements().
 */
function name_elements() {
  $parts = _name_translations();
  $field_info = name_field_info();
  $name_info = $field_info['name'];
  $field_settings = $name_info['field_settings'];
  return array(
    'name_element' => array(
      '#input' => TRUE,
      '#process' => array('name_element_expand'),
      '#element_validate' => array('name_element_validate'),
      '#pre_render' =>  array('name_element_pre_render'),
      '#default_value' => array('title' => '', 'given' => '', 'middle' => '',
          'family' => '', 'generational' => '', 'credentials' => ''),
      '#minimum_components' => $field_settings['minimum_components'],
      '#components' => array(
        'title' => array(
          'type' => $name_info['instance_settings']['title_field'],
          'description' => $parts['title'],
          'size' => $name_info['instance_settings']['size']['title'],
          'maxlength' => $field_settings['max_length']['title'],
          'options' => $field_settings['title_options'],
          'autocomplete' => FALSE,
        ),
        'given' => array(
          'type' => 'textfield',
          'description' => $parts['given'],
          'size' => $name_info['instance_settings']['size']['given'],
          'maxlength' => $field_settings['max_length']['given'],
          'autocomplete' => FALSE,
        ),
        'middle' => array(
          'type' => 'textfield',
          'description' => $parts['middle'],
          'size' => $name_info['instance_settings']['size']['middle'],
          'maxlength' => $field_settings['max_length']['middle'],
          'autocomplete' => FALSE,
        ),
        'family' => array(
          'type' => 'textfield',
          'description' => $parts['family'],
          'size' => $name_info['instance_settings']['size']['family'],
          'maxlength' => $field_settings['max_length']['family'],
          'autocomplete' => FALSE,
        ),
        'generational' => array(
          'type' => $name_info['instance_settings']['generational_field'],
          'description' => $parts['generational'],
          'size' => $name_info['instance_settings']['size']['generational'],
          'maxlength' => $name_info['field_settings']['max_length']['generational'],
          'options' => $name_info['field_settings']['generational_options'],
          'autocomplete' => FALSE,
        ),
        'credentials' => array(
          'type' => 'textfield',
          'description' => $parts['credentials'],
          'size' => $name_info['instance_settings']['size']['credentials'],
          'maxlength' => $name_info['field_settings']['max_length']['credentials'],
          'autocomplete' => FALSE,
        ),
      ),
    )
  );
}

/**
 * Custom theme callback for the name_element.
 */
function theme_name_element($element) {
  return theme('form_element', $element, $element['#children']);
}

/**
 * The #process callback to create the element.
 */
function name_element_expand($element, $edit, &$form_state, $complete_form) {
  $element['#tree'] = TRUE;
  if (empty($element['#value'])) {
    $element['#value'] = array('title' => '', 'given' => '', 'middle' => '',
        'family' => '', 'generational' => '', 'credentials' => '');
  }
  $components = $element['#components'];
  $min_components = (array) $element['#minimum_components'];

  foreach (_name_translations() as $key => $title) {
    if (!isset($components[$key]['exclude'])) {
      $element[$key] = _name_render_component($components[$key], $key, $element['#value'][$key], isset($min_components[$key]));
      if ($key == 'credentials') {
        $element[$key]['#prefix'] = '<div class="clear-block" style="float: left;">';
        $element[$key]['#suffix'] = '</div>';
      }
      else {
        $element[$key]['#prefix'] = '<div style="float: left; margin-right: 1em;">';
        $element[$key]['#suffix'] = '</div>';
      }
    }
  }

  // Try to prevent wrapping errors without any additional styles.
  $element['#prefix'] = '<div class="clear-block">';
  $element['#suffix'] = '</div>';

  $element['#pre_render'] = array('_name_element_prerender');
  return $element;
}

function _name_render_component($component, $name, $value, $core) {
  $element = array(
    '#attributes' => array(
      'class' => 'name-element name-'. $name . ($core ? ' name-core-component' : ''),
    ),
  );
  $base_attributes = array('type', 'description', 'size', 'maxlength');
  foreach ($base_attributes as $key) {
    $element['#'. $key] = $component[$key];
  }
  $element['#default_value'] = $value;
  if ($component['type'] == 'select') {
    $element['#options'] = $component['options'];
    $element['#size'] = 1;
  }
  elseif (!empty($component['autocomplete'])) {
    $element['#autocomplete_path'] = $component['autocomplete'];
  }
  return $element;
}

function name_element_validate($element, &$form_state) {
  $minimum_components = array_filter($element['#minimum_components']);
  $labels = array();
  foreach ($element['#components'] as $key => $component) {
    if (!isset($component['exclude'])) {
      $labels[$key] = $component['description'];
    }
  }
  $item = $element['#value'];
  $empty = name_content_is_empty($item, NULL);
  $item_components = array();
  foreach (_name_translations() as $key => $title) {
    if (isset($labels[$key]) && !empty($item[$key])) {
      $item_components[$key] = $item[$key];
    }
  }
  if (!$empty && (count($minimum_components) != count(array_intersect_key($minimum_components, $item_components)))) {
    $missing_labels = array_diff_key(array_intersect_key($labels, $minimum_components), $item_components);
    $label = empty($element['#title']) ? (empty($element['#label']) ? 'Field' : $element['#label']) : $element['#title'];
    form_error($element[key($missing_labels)], t('%name also requires the following parts: %components.',
      array('%name' => $label, '%components' => implode(', ', $missing_labels))));
  }

  return $element;
}

/**
 * This forces the error class attribute onto each of the empty element components.
 *
 * TODO: There is a lot of WTF here. Why does this need such a hack to
 * propagate the error class down? Is the error element name wrong??
 */
function name_element_pre_render($element) {
  $error_element = empty($element['_error_element']['#value']) ? '' : $element['_error_element']['#value'] .'][';
  $error_element .= $element['#name'];
  $errors = (array) form_set_error();
  foreach ($errors as $error_key => $error) {
    if (strpos($error_key, $error_element) === 0) {
      foreach (_name_translations() as $key => $title) {
        if (isset($element[$key]) && empty($element[$key]['#value'])) {
          $element[$key]['#attributes']['class'] .= ' error';
        }
      }
    }
  }
  return $element;
}

/**
 * A hack to theme the FAPI name elements sub-elements. These are not available
 * using the theme_name_element() function.
 */
function _name_element_prerender($element) {
  // Add a wrapper to single fields that have a description to prevent wrapping.
  if (!empty($element['#description']) && !empty($element['#description'])) {
    $field = NULL;
    if (isset($element['#field_name']) && isset($element['#type_name'])) {
      $field = content_fields($element['#field_name'], $element['#type_name']);
    }
    if (!$field || !$field['multiple']) {
      $element['_name'] = array(
        '#prefix' => '<div class="clear-block">',
        '#suffix' => '</div>',
      );
      foreach (_name_translations() as $key => $title) {
        if (isset($element[$key])) {
          $element['_name'][$key] = $element[$key];
          unset($element[$key]);
        }
      }
      $element['_description'] = array(
        '#value' => '<div class="clear-block description">' . $element['#description'] . '</div>',
      );
      unset($element['#description']);
    }
  }

  return $element;
}
